---
layout: post
title: "面试题 08.11. 硬币.md"
date: 2022-09-10 14:35:41 +0800
categories: 算法
tags: leetcode 程序员面试宝典
author: Zhijie Wang
mathjax: true
---


* content
{:toc}














# 面试题 08.11. 硬币

## 背包三讲

## 01背包

01背包就是所有物品只有拿一件和不拿两种选择

f[i][j]表示只拿前i个物品，且背包容量只有j时，背包装下的最大价值

状态转移方程：

f[i][j]=f[i-1][j]  当前物品太重，放不下

f[i][j]=max{ f[i-1][j] , f[i-1][j-w[i]]+v[i] }  拿当前物品总价值高还是不拿总价值高

优化后：

只需一维数组来记录状态，f[j]表示背包容量为j时，可选前i-1件物品的最大价值，没更新前是i-1个物品，更新后是i个物品

因为当前的取值需要前面的旧值，因此从后往前遍历赋值，以免旧值被覆盖

## 完全背包

完全背包就是所有物品只有拿（可重复）和不拿两种选择

状态转移方程：

f[i][j]=f[i-1][j]  当前物品太重，放不下

f[i][j]=max{ f[i-1][j] ,f[i][j-w[i]]+v[i] }  在更新过的基础上再拿一件

优化后：

因为当前取值需要前面的旧值和前面的新值，因此从前往后遍历赋值，能获取新值



总结:

01背包和完全背包的区别就是从后往前和从前往后遍历赋值

## 背包问题的方案数

把动态规划数组由记录最大价值变为记录最大方案数

初始化f[0]=1，表示装满容量为0的背包有1种方案（就是什么也不装）

状态转移方程：

01背包问题的方案数：

f[i][j]=f[i-1][j]+f[i-1][j-w[i]]

优化后：

从后往前遍历赋值

f[j]=f[j]+f[j-w[i]]    （不选的总方案数+选的总方案数）



完全背包问题的方案数：

f[i][j]=f[i-1][j]+f[i][j-w[i]]

优化后：

从前往后遍历赋值

f[j]=f[j]+f[j-w[i]]    （不选的总方案数+选的总方案数）



题目：硬币。给定数量不限的硬币，币值为25分、10分、5分和1分，编写代码计算n分有几种表示法。(结果可能会很大，你需要将结果模上1000000007)

```java
class Solution {
    public int waysToChange(int n) {
        int[]f=new int[n+1];
        int[] coin={25,10,5,1};
        f[0]=1;
        for(int i=0;i<4;i++){
            int cur=coin[i];
            for(int j=cur;j<=n;j++){
                f[j]=(f[j]+f[j-cur])%1000000007;
            }
        }
        return f[n];
    }
}
```

