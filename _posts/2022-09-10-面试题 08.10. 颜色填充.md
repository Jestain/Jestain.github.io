---
layout: post
title: "面试题 08.10. 颜色填充.md"
date: 2022-09-10 14:35:41 +0800
categories: 算法
tags: leetcode 程序员面试宝典
author: Zhijie Wang
mathjax: true
---


* content
{:toc}














# 面试题 08.10. 颜色填充

题目：编写函数，实现许多图片编辑软件都支持的「颜色填充」功能。

待填充的图像用二维数组 image 表示，元素为初始颜色值。初始坐标点的行坐标为 sr 列坐标为 sc。需要填充的新颜色为 newColor 。

「周围区域」是指颜色相同且在上、下、左、右四个方向上存在相连情况的若干元素。

请用新颜色填充初始坐标点的周围区域，并返回填充后的图像。



![](D:/下载/youdaonote-pull-master/youdaonote-pull-master/youdaonote/youdaonote-images/WEBRESOURCE2d7b2c8e3ca80846ecd7271b3696a6b8.png)

套路：深度优先搜索

1. 递归出口：越过边界+当前颜色不是oldColor

2. 把当前颜色设置为newColor

3. 对上下左右分别递归

```java
class Solution {
    public int[][] floodFill(int[][] image, int sr, int sc, int newColor) {
        if(newColor==image[sr][sc]){
            return image;
        }
        dfs(image,sr,sc,image[sr][sc],newColor);
        return image;
    }
    private void dfs(int[][] image,int sr,int sc,int oldColor,int newColor){
        if(sr<0||sr>=image.length||sc<0||sc>=image[0].length||image[sr][sc]!=oldColor){
            return;
        }
        image[sr][sc]=newColor;
        dfs(image,sr+1,sc,oldColor,newColor);
        dfs(image,sr,sc+1,oldColor,newColor);
        dfs(image,sr-1,sc,oldColor,newColor);
        dfs(image,sr,sc-1,oldColor,newColor);
    }
}
```

还有一个方法，广度优先，复杂度比深度优先高

思路是定义一个方向数组，队列不为空时，出队，判断四个方向是否符合要求(边界+是否为oldColor)

符合要求的：颜色置为newColor 入队

```java
class Solution {
    public int[][] floodFill(int[][] image, int sr, int sc, int newColor) {      
        if(image[sr][sc]==newColor){
            return image;
        }
        Deque<int[]>de=new LinkedList<>();
        int[][]direct={{0,1},{1,0},{0,-1},{-1,0}};
        int oldColor=image[sr][sc];
        image[sr][sc]=newColor;
        int r=image.length,c=image[0].length;
        de.offer(new int[]{sr,sc});
        while(!de.isEmpty()){
            int[]get=de.poll();
            for(int i=0;i<direct.length;i++){
                    int next_r=get[0]+direct[i][0];
                    int next_c=get[1]+direct[i][1];
                    if(next_r>=0&&next_r<=r-1&&next_c>=0&&next_c<=c-1&&image[next_r][next_c]==oldColor){
                        image[next_r][next_c]=newColor;
                        de.offer(new int[]{next_r,next_c});
                    }                   
                }          
        }
        return image;
    }
}
```
