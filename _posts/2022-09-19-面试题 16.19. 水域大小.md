---
layout: post
title: "面试题 16.19. 水域大小.md"
date: 2022-09-19 14:35:41 +0800
categories: 算法
tags: leetcode 程序员面试宝典
author: Zhijie Wang
mathjax: true
---


* content
{:toc}














# 面试题 16.19. 水域大小

题目：你有一个用于表示一片土地的整数矩阵land，该矩阵中每个点的值代表对应地点的海拔高度。若值为0则表示水域。由垂直、水平或对角连接的水域为池塘。池塘的大小是指相连接的水域的个数。编写一个方法来计算矩阵中所有池塘的大小，返回值需要从小到大排序。

套路：用深度优先搜索

遍历每一个元素，如果为0，则对它进行dfs

dfs的实现：

1. 递归出口，边界+当前值不为0

1. num分别num+1再加上下左右、左上左下、右上右下递归返回的值

```java
class Solution {
    public int[] pondSizes(int[][] land) {
        if(land==null||land.length==0||land[0].length==0){
            return new int[]{};
        }
        List<Integer> res=new ArrayList<>();
        for(int i=0;i<land.length;i++){
            for(int j=0;j<land[0].length;j++){
                int tmp=dfs(land,i,j);
                if(tmp!=0){
                    res.add(tmp);
                }
            }
        }
        int[] re=new int[res.size()];
        for(int i=0;i<res.size();i++){
            re[i]=res.get(i);
        }
        Arrays.sort(re);
        return re;
    }
    private int dfs(int[][] land,int i,int j){
        int num=0;
        if(i<0||j>=land[0].length||i>=land.length||j<0||land[i][j]!=0){
            return num;
        }
        num++;
        land[i][j]=-1;
        num+=dfs(land,i+1,j);
        num+=dfs(land,i,j+1);
        num+=dfs(land,i-1,j);
        num+=dfs(land,i,j-1);
        num+=dfs(land,i+1,j+1);
        num+=dfs(land,i-1,j-1);
        num+=dfs(land,i+1,j-1);
        num+=dfs(land,i-1,j+1);
        return num;
    }
}
```

广度优先搜索：

1. 遍历每一个元素，为0则：

- 入队，开始循环，当队列不为空时

- 出队

- 取八个方向上的邻居（提前设置方向数组），如果为0，则num++，把该位置元素置-1，入队

1. 之后把结果加入结果集

2. ArrayList转int[]

```java
class Solution {
    public int[] pondSizes(int[][] land) {
        if(land==null||land.length==0||land[0].length==0){
            return new int[]{};
        }
        List<Integer> res=new ArrayList<>();
        Deque<int[]> de=new LinkedList<>();
        int num=0;
        int[][] direct=new int[][]{{1,0},{0,1},{-1,0},{0,-1},{1,1},{-1,-1},{-1,1},{1,-1}};
        for(int i=0;i<land.length;++i){
            for(int j=0;j<land[0].length;++j){
                if(land[i][j]==0){
                    num=1;
                    land[i][j]=-1;
                    de.offer(new int[]{i,j});
                    while(!de.isEmpty()){
                        int[] tmp=de.pop();
                        for(int k=0;k<direct.length;++k){
                            if(tmp[0]+direct[k][0]>=0&&tmp[0]+direct[k][0]<land.length&&tmp[1]+direct[k][1]<land[0].length&&tmp[1]+direct[k][1]>=0){
                                if(land[tmp[0]+direct[k][0]][tmp[1]+direct[k][1]]==0){
                                num++;
                                land[tmp[0]+direct[k][0]][tmp[1]+direct[k][1]]=-1;
                                de.offer(new int[]{tmp[0]+direct[k][0],tmp[1]+direct[k][1]});
                            }
                            }

                        }
                    }
                    res.add(num);
                }
            }
        }
        int[] re=new int[res.size()];
        for(int i=0;i<res.size();++i){
            re[i]=res.get(i);
        }
        Arrays.sort(re);
        return re;
    }
}
```
