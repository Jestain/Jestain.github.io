---
layout: post
title: "面试题 16.22. 兰顿蚂蚁.md"
date: 2022-09-20 14:35:41 +0800
categories: 算法
tags: leetcode 程序员面试宝典
author: Zhijie Wang
mathjax: true
---


* content
{:toc}














# 面试题 16.22. 兰顿蚂蚁

题目：一只蚂蚁坐在由白色和黑色方格构成的无限网格上。开始时，网格全白，蚂蚁面向右侧。每行走一步，蚂蚁执行以下操作。

(1) 如果在白色方格上，则翻转方格的颜色，向右(顺时针)转 90 度，并向前移动一个单位。

(2) 如果在黑色方格上，则翻转方格的颜色，向左(逆时针方向)转 90 度，并向前移动一个单位。

编写程序来模拟蚂蚁执行的前 K 个动作，并返回最终的网格。

网格由数组表示，每个元素是一个字符串，代表网格中的一行，黑色方格由 'X' 表示，白色方格由 '_' 表示，蚂蚁所在的位置由 'L', 'U', 'R', 'D' 表示，分别表示蚂蚁 左、上、右、下 的朝向。只需要返回能够包含蚂蚁走过的所有方格的最小矩形。

题目解读：

先更新当前位置颜色，再更新方向，再走

套路：内部类+哈希集合

1. 定义一个内部类，用于记录蚂蚁的位置，能够添加到哈希集合

1. 定义两个集合，一个存放黑色方块的位置，一个存放走过的所有位置

1. 定义方向数组，方向下标，方向字符数组

1. 当K>0时：

- 获取蚂蚁当前的位置，new一个对象

- 添加进黑色方块集合，能添加则说明此位置原本为白色，则方向下标+1除余4

- 不能添加进说明此位置为黑色，则方向下标+3除余4，再从集合中移除

- 添加进路径集合

- 更新蚂蚁的位置

- K--

此时黑色集合存放了所有的黑色方块的位置，路径集合存放了所有蚂蚁走过的路径。

1. 遍历路径集合，更新边界

1. 创建一个二维字符数组board，new char[top-bottom+1][right-left+1]

1. 把用'_'填满，表示白色方块

1. 遍历黑色集合，更新黑色方块

1. 根据蚂蚁当前位置和蚂蚁方向，更新蚂蚁位置

```java
class Solution {
    class Position{
        int x;
        int y;
        Position(int x,int y){
            this.x=x;
            this.y=y;
        }
        public boolean equals(Object o){
            if(this==o){
                return true;
            }
            if(!(o instanceof Position)){
                return false;
            }
            Position p=(Position)o;
            return p.x==this.x&&p.y==this.y;
        }
        public int hashCode(){
            int res=60*x+35*y;
            return res;
        }
    }
    public List<String> printKMoves(int K) {
        char[] direction=new char[]{'L','U','R','D'};
        int[][] offset=new int[][]{{-1,0},{0,-1},{1,0},{0,1}};
        int antDir=2;
        Position antP=new Position(0,0);
        Set<Position> black=new HashSet<>();
        // path记录走过的位置
        Set<Position> path=new HashSet<>();
        while(K>0){
            Position p=new Position(antP.x,antP.y);
            if(black.add(p)){
                antDir=(antDir+1)%4;
            }else{
                antDir=(antDir+3)%4;
                black.remove(p);
           }
           path.add(p);
        //    先更新位置，再更新方向
           antP.x=antP.x+offset[antDir][0];
           antP.y=antP.y+offset[antDir][1];
           K--;
        }
        int left=antP.x,right=antP.x,bottom=antP.y,top=antP.y;
        for(Position pos:path){
            left=left<pos.x?left:pos.x;
            right=right>pos.x?right:pos.x;
            bottom=bottom<pos.y?bottom:pos.y;
            top=top>pos.y?top:pos.y;
        }
        char[][] board=new char[top-bottom+1][right-left+1];
        for(char[] row:board){
            Arrays.fill(row,'_');
        }
        for(Position po:black){
            board[po.y-bottom][po.x-left]='X';
        }
        board[antP.y-bottom][antP.x-left]=direction[antDir];
        List<String> result=new ArrayList<>();
        for(char[] c:board){
            result.add(new String(c));
        }
        return result;
    }
}
```

